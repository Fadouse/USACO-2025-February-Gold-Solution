### 核心思路

1. **区间翻转的压缩表示**
   - 使用**差分数列**记录翻转操作：每个翻转区间`[l,r]`在`l`处+1，`r+1`处-1
   - 对关键端点排序后扫描，生成**分段常量区间**：
     
     $`
     \text{finalBit}(x) = (\text{prefixSum}(x) \mod 2)
     `$
   - 合并相邻相同状态的区间，最终形成`O(M)`个连续段

2. **查询处理**
   - 对每个查询`[L,R]`，通过**二分查找**快速定位相关区间段
   - 生成查询范围内的子区间段列表`{(bit, len)}`

3. **字典序最大子序列**
   - 采用贪心策略：
     - 优先从左到右选取尽可能多的`1`
       
     $`
     \text{选取数量} = \min(\text{当前段1的数量}, \text{剩余需要选取数})
     `$
     - 对`0`段：尽可能跳过左侧的0，仅在必须时从右侧选取

4. **快速模运算**
   - 使用快速幂计算`2^x mod (1e9+7)`
   - 对连续`x`个相同bit的追加操作：
     
     $`
     \text{新值} = 
     \begin{cases} 
     (\text{原值} \times 2^x) \mod P & \text{bit=0} \\
     (\text{原值} \times 2^x + (2^x - 1)) \mod P & \text{bit=1}
     \end{cases}
     `$

### 复杂度分析
- **预处理**：`O(M log M)`（端点排序与合并）
- **单次查询**：`O(log M + S)`，其中S为查询区间覆盖的段数
  - 二分查找：`O(log M)`
  - 贪心处理段：每段`O(1)`时间（利用快速幂）
